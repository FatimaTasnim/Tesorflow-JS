"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const linechart_1 = require("../render/linechart");
const render_utils_1 = require("../render/render_utils");
const dom_1 = require("../util/dom");
function history(container, history, metrics, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const plots = {};
        for (const metric of metrics) {
            if (!(/val_/.test(metric))) {
                const values = getValues(history, metric, metrics.indexOf(metric));
                initPlot(plots, metric);
                plots[metric].series.push(metric);
                plots[metric].values.push(values);
            }
            else {
                const nonValidationMetric = metric.replace('val_', '');
                initPlot(plots, nonValidationMetric);
                const values = getValues(history, metric, metrics.indexOf(metric));
                plots[nonValidationMetric].series.push(metric);
                plots[nonValidationMetric].values.push(values);
            }
        }
        const plotNames = Object.keys(plots);
        const options = Object.assign({}, { xLabel: 'Iteration', yLabel: 'Value' }, opts);
        const renderPromises = [];
        for (const name of plotNames) {
            const subContainer = dom_1.subSurface(drawArea, name);
            const series = plots[name].series;
            const values = plots[name].values;
            if (series.every(seriesName => Boolean(seriesName.match('acc')))) {
                if (options.zoomToFitAccuracy) {
                    options.zoomToFit = true;
                }
                else {
                    options.yAxisDomain = [0, 1];
                    delete options.zoomToFit;
                }
            }
            const done = linechart_1.linechart(subContainer, { values, series }, options);
            renderPromises.push(done);
        }
        yield Promise.all(renderPromises);
    });
}
exports.history = history;
function initPlot(plot, name) {
    if (plot[name] == null) {
        plot[name] = { series: [], values: [] };
    }
}
function getValues(history, metric, metricIndex) {
    if (Array.isArray(history)) {
        const metricHistory = (Array.isArray(history[0]) ? history[metricIndex] : history);
        const points = [];
        for (let i = 0; i < metricHistory.length; i++) {
            const log = metricHistory[i];
            points.push({ x: i, y: log[metric] });
        }
        return points;
    }
    else {
        return history.history[metric].map((y, x) => ({ x, y }));
    }
}
function fitCallbacks(container, metrics, opts = {}) {
    const accumulators = {};
    const callbackNames = opts.callbacks || ['onEpochEnd', 'onBatchEnd'];
    const drawArea = render_utils_1.getDrawArea(container);
    const historyOpts = Object.assign({}, opts);
    delete historyOpts.callbacks;
    function makeCallbackFor(callbackName) {
        return (_, log) => __awaiter(this, void 0, void 0, function* () {
            if ((/batch/i).test(callbackName)) {
                historyOpts.xLabel = 'Batch';
            }
            else if ((/epoch/i).test(callbackName)) {
                historyOpts.xLabel = 'Epoch';
            }
            const metricLogs = [];
            const presentMetrics = [];
            for (const metric of metrics) {
                if (log[metric] != null) {
                    presentMetrics.push(metric);
                    const accumulator = getAccumulator(accumulators, callbackName, metric);
                    accumulator.push({ [metric]: log[metric] });
                    metricLogs.push(accumulator);
                }
            }
            const subContainer = dom_1.subSurface(drawArea, callbackName, { title: callbackName });
            history(subContainer, metricLogs, presentMetrics, historyOpts);
            yield render_utils_1.nextFrame();
        });
    }
    const callbacks = {};
    callbackNames.forEach((name) => {
        callbacks[name] = makeCallbackFor(name);
    });
    return callbacks;
}
exports.fitCallbacks = fitCallbacks;
function getAccumulator(accumulators, callback, metric) {
    if (accumulators[callback] == null) {
        accumulators[callback] = {};
    }
    if (accumulators[callback][metric] == null) {
        accumulators[callback][metric] = [];
    }
    return accumulators[callback][metric];
}
//# sourceMappingURL=history.js.map