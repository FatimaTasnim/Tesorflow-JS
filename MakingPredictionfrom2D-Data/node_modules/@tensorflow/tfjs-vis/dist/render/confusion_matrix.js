"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vega_embed_1 = __importDefault(require("vega-embed"));
const render_utils_1 = require("./render_utils");
function confusionMatrix(container, data, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = Object.assign({}, defaultOpts, opts);
        const drawArea = render_utils_1.getDrawArea(container);
        const values = [];
        const inputArray = data.values;
        const tickLabels = data.tickLabels || [];
        const generateLabels = tickLabels.length === 0;
        let nonDiagonalIsAllZeroes = true;
        for (let i = 0; i < inputArray.length; i++) {
            const label = generateLabels ? `Class ${i}` : tickLabels[i];
            if (generateLabels) {
                tickLabels.push(label);
            }
            for (let j = 0; j < inputArray[i].length; j++) {
                const prediction = generateLabels ? `Class ${j}` : tickLabels[j];
                const count = inputArray[i][j];
                if (i === j && !options.shadeDiagonal) {
                    values.push({
                        label,
                        prediction,
                        diagCount: count,
                        noFill: true,
                    });
                }
                else {
                    values.push({
                        label,
                        prediction,
                        count,
                    });
                    if (count !== 0) {
                        nonDiagonalIsAllZeroes = false;
                    }
                }
            }
        }
        if (!options.shadeDiagonal && nonDiagonalIsAllZeroes) {
            for (const val of values) {
                if (val.noFill === true) {
                    val.noFill = false;
                    val.count = val.diagCount;
                }
            }
        }
        const embedOpts = {
            actions: false,
            mode: 'vega-lite',
            defaultStyle: false,
        };
        const spec = {
            'width': options.width || drawArea.clientWidth,
            'height': options.height || drawArea.clientHeight,
            'padding': 0,
            'autosize': {
                'type': 'fit',
                'contains': 'padding',
                'resize': true,
            },
            'config': {
                'axis': {
                    'labelFontSize': options.fontSize,
                    'titleFontSize': options.fontSize,
                },
                'text': { 'fontSize': options.fontSize },
                'legend': {
                    'labelFontSize': options.fontSize,
                    'titleFontSize': options.fontSize,
                }
            },
            'data': { 'values': values },
            'encoding': {
                'x': {
                    'field': 'prediction',
                    'type': 'ordinal',
                    'scale': { 'domain': tickLabels },
                },
                'y': {
                    'field': 'label',
                    'type': 'ordinal',
                    'scale': { 'domain': tickLabels },
                },
            },
            'layer': [
                {
                    'mark': {
                        'type': 'rect',
                    },
                    'encoding': {
                        'fill': {
                            'condition': {
                                'test': 'datum["noFill"] == true',
                                'value': 'white',
                            },
                            'field': 'count',
                            'type': 'quantitative',
                            'scale': { 'range': ['#f7fbff', '#4292c6'] },
                        },
                        'tooltip': {
                            'condition': {
                                'test': 'datum["noFill"] == true',
                                'field': 'diagCount',
                                'type': 'nominal',
                            },
                            'field': 'count',
                            'type': 'nominal',
                        }
                    },
                },
            ]
        };
        if (options.showTextOverlay) {
            spec.layer.push({
                'mark': { 'type': 'text', 'baseline': 'middle' },
                'encoding': {
                    'text': {
                        'condition': {
                            'test': 'datum["noFill"] == true',
                            'field': 'diagCount',
                            'type': 'nominal',
                        },
                        'field': 'count',
                        'type': 'nominal',
                    },
                }
            });
        }
        yield vega_embed_1.default(drawArea, spec, embedOpts);
        return Promise.resolve();
    });
}
exports.confusionMatrix = confusionMatrix;
const defaultOpts = {
    xLabel: null,
    yLabel: null,
    xType: 'nominal',
    yType: 'nominal',
    shadeDiagonal: true,
    fontSize: 12,
    showTextOverlay: true,
    height: 400,
};
//# sourceMappingURL=confusion_matrix.js.map