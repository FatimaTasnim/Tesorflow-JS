{"version":3,"file":"heatmap.js","sourceRoot":"","sources":["../../src/render/heatmap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {Drawable, HeatmapData, HeatmapOptions} from '../types';\nimport {assert} from '../util/utils';\n\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function heatmap(\n    container: Drawable, data: HeatmapData,\n    opts: HeatmapOptions = {}): Promise<void> {\n  const options = Object.assign({}, defaultOpts, opts);\n  const drawArea = getDrawArea(container);\n\n  let inputValues = data.values;\n  if (options.rowMajor) {\n    let originalShape: number[];\n    let transposed: tf.Tensor2D;\n    if (inputValues instanceof tf.Tensor) {\n      originalShape = inputValues.shape;\n      transposed = inputValues.transpose();\n    } else {\n      originalShape = [inputValues.length, inputValues[0].length];\n      transposed =\n          tf.tidy(() => tf.tensor2d(inputValues as number[][]).transpose());\n    }\n\n    assert(\n        transposed.rank === 2,\n        'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n    // Download the intermediate tensor values and\n    // dispose the transposed tensor.\n    inputValues = await transposed.array();\n    transposed.dispose();\n\n    const transposedShape = [inputValues.length, inputValues[0].length];\n    assert(\n        originalShape[0] === transposedShape[1] &&\n            originalShape[1] === transposedShape[0],\n        `Unexpected transposed shape. Original ${originalShape} : Transposed ${\n            transposedShape}`);\n  }\n\n  // Format data for vega spec; an array of objects, one for for each cell\n  // in the matrix.\n  const values: MatrixEntry[] = [];\n  const {xTickLabels, yTickLabels} = data;\n\n  // These two branches are very similar but we want to do the test once\n  // rather than on every element access\n  if (inputValues instanceof tf.Tensor) {\n    assert(\n        inputValues.rank === 2,\n        'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n    const shape = inputValues.shape;\n    if (xTickLabels) {\n      assert(\n          shape[0] === xTickLabels.length,\n          `Length of xTickLabels (${\n              xTickLabels.length}) must match number of rows\n          (${shape[0]})`);\n    }\n\n    if (yTickLabels) {\n      assert(\n          shape[1] === yTickLabels.length,\n          `Length of yTickLabels (${\n              yTickLabels.length}) must match number of columns\n          (${shape[1]})`);\n    }\n\n    // This is a slightly specialized version of TensorBuffer.get, inlining it\n    // avoids the overhead of a function call per data element access and is\n    // specialized to only deal with the 2d case.\n    const inputArray = await inputValues.data();\n    const [numRows, numCols] = shape;\n\n    for (let row = 0; row < numRows; row++) {\n      const x = xTickLabels ? xTickLabels[row] : row;\n      for (let col = 0; col < numCols; col++) {\n        const y = yTickLabels ? yTickLabels[col] : col;\n\n        const index = (row * numCols) + col;\n        const value = inputArray[index];\n\n        values.push({x, y, value});\n      }\n    }\n  } else {\n    if (xTickLabels) {\n      assert(\n          inputValues.length === xTickLabels.length,\n          `Number of rows (${inputValues.length}) must match\n          number of xTickLabels (${xTickLabels.length})`);\n    }\n\n    const inputArray = inputValues as number[][];\n    for (let row = 0; row < inputArray.length; row++) {\n      const x = xTickLabels ? xTickLabels[row] : row;\n      if (yTickLabels) {\n        assert(\n            inputValues[row].length === yTickLabels.length,\n            `Number of columns in row ${row} (${inputValues[row].length})\n            must match length of yTickLabels (${yTickLabels.length})`);\n      }\n      for (let col = 0; col < inputArray[row].length; col++) {\n        const y = yTickLabels ? yTickLabels[col] : col;\n        const value = inputArray[row][col];\n        values.push({x, y, value});\n      }\n    }\n  }\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  const spec: VisualizationSpec = {\n    'width': options.width || drawArea.clientWidth,\n    'height': options.height || drawArea.clientHeight,\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'scale': {'bandPaddingInner': 0, 'bandPaddingOuter': 0},\n    },\n    'data': {'values': values},\n    'mark': 'rect',\n    'encoding': {\n      'x': {\n        'field': 'x',\n        'type': options.xType,\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': xTickLabels},\n        'title': options.xLabel,\n      },\n      'y': {\n        'field': 'y',\n        'type': options.yType,\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': yTickLabels},\n        'title': options.yLabel,\n      },\n      'fill': {\n        'field': 'value',\n        'type': 'quantitative',\n      },\n    }\n  };\n\n  let colorRange: string[]|string;\n  switch (options.colorMap) {\n    case 'blues':\n      colorRange = ['#f7fbff', '#4292c6'];\n      break;\n    case 'greyscale':\n      colorRange = ['#000000', '#ffffff'];\n      break;\n    case 'viridis':\n    default:\n      colorRange = 'viridis';\n      break;\n  }\n\n  if (colorRange !== 'viridis') {\n    const fill = spec.encoding!.fill;\n    // @ts-ignore\n    fill.scale = {'range': colorRange};\n  }\n\n  if (options.domain) {\n    const fill = spec.encoding!.fill;\n    // @ts-ignore\n    if (fill.scale != null) {\n      // @ts-ignore\n      fill.scale = Object.assign({}, fill.scale, {'domain': options.domain});\n    } else {\n      // @ts-ignore\n      fill.scale = {'domain': options.domain};\n    }\n  }\n\n  await embed(drawArea, spec, embedOpts);\n}\n\nconst defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false,\n};\n\ninterface MatrixEntry {\n  x: string|number;\n  y: string|number;\n  value: number;\n}\n"]}