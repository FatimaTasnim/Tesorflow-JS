"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tfjs_1 = require("@tensorflow/tfjs");
const utils_1 = require("./utils");
function arrayStats(input) {
    if (!Array.isArray(input)) {
        throw new Error('input must be an array');
    }
    if (input.length === 0) {
        return {
            numVals: 0,
            numNans: 0,
            numZeros: 0,
            max: undefined,
            min: undefined,
        };
    }
    const numVals = input.length;
    let max = -Infinity;
    let min = Infinity;
    let numZeros = 0;
    let numNans = 0;
    let numInfs = 0;
    for (let i = 0; i < numVals; i++) {
        const curr = input[i];
        if (curr > max) {
            max = curr;
        }
        if (curr < min) {
            min = curr;
        }
        if (curr === 0) {
            numZeros += 1;
        }
        if (isNaN(curr)) {
            numNans += 1;
        }
        else if (!isFinite(curr)) {
            numInfs += 1;
        }
    }
    const result = {
        numVals,
        numZeros,
        numNans,
        max,
        min,
        numInfs,
    };
    if (result.max === -Infinity) {
        result.max = NaN;
    }
    if (result.min === Infinity) {
        result.min = NaN;
    }
    return result;
}
exports.arrayStats = arrayStats;
function tensorStats(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const [min, max, numZeros] = tfjs_1.tidy(() => {
            const zero = tfjs_1.scalar(0, input.dtype);
            const min = input.min();
            const max = input.max();
            const numZeros = input.equal(zero).sum();
            return [min, max, numZeros];
        });
        return yield Promise
            .all([input.data(), min.data(), max.data(), numZeros.data()])
            .then(([tensorVal, minVal, maxVal, numZerosVal]) => {
            const numVals = tensorVal.length;
            let numNans = 0;
            let numInfs = 0;
            for (let i = 0; i < numVals; i++) {
                const curr = tensorVal[i];
                if (isNaN(curr)) {
                    numNans += 1;
                }
                else if (!isFinite(curr)) {
                    numInfs += 1;
                }
            }
            let trueMin = minVal[0];
            let trueMax = maxVal[0];
            if (numNans === numVals) {
                trueMin = NaN;
                trueMax = NaN;
            }
            const stats = {
                numVals,
                numZeros: numZerosVal[0],
                numNans,
                min: trueMin,
                max: trueMax,
                numInfs,
            };
            return stats;
        });
    });
}
exports.tensorStats = tensorStats;
function confusionMatrix(labels, predictions, numClasses, weights) {
    return __awaiter(this, void 0, void 0, function* () {
        utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');
        utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');
        utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');
        if (weights != null) {
            utils_1.assert(weights.size === predictions.size, 'labels and predictions must be the same length');
        }
        const labelsInt = labels.cast('int32');
        const predictionsInt = predictions.cast('int32');
        if (numClasses == null) {
            numClasses =
                tfjs_1.tidy(() => {
                    const max = tfjs_1.maximum(labelsInt.max(), predictionsInt.max()).cast('int32');
                    return max.dataSync()[0] + 1;
                });
        }
        let weightsPromise = Promise.resolve(null);
        if (weights != null) {
            weightsPromise = weights.data();
        }
        return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise])
            .then(([labelsArray, predsArray, weightsArray]) => {
            const result = Array(numClasses).fill(0);
            for (let i = 0; i < numClasses; i++) {
                result[i] = Array(numClasses).fill(0);
            }
            for (let i = 0; i < labelsArray.length; i++) {
                const label = labelsArray[i];
                const pred = predsArray[i];
                if (weightsArray != null) {
                    result[label][pred] += weightsArray[i];
                }
                else {
                    result[label][pred] += 1;
                }
            }
            return result;
        });
    });
}
exports.confusionMatrix = confusionMatrix;
function accuracy(labels, predictions) {
    return __awaiter(this, void 0, void 0, function* () {
        utils_1.assertShapesMatch(labels.shape, predictions.shape, 'Error computing accuracy.');
        const eq = labels.equal(predictions);
        const mean = eq.mean();
        const acc = (yield mean.data())[0];
        tfjs_1.dispose([eq, mean]);
        return acc;
    });
}
exports.accuracy = accuracy;
function perClassAccuracy(labels, predictions, numClasses) {
    return __awaiter(this, void 0, void 0, function* () {
        utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');
        utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');
        utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');
        if (numClasses == null) {
            numClasses = tfjs_1.tidy(() => {
                return tfjs_1.maximum(labels.max(), predictions.max()).dataSync()[0] + 1;
            });
        }
        return Promise.all([labels.data(), predictions.data()])
            .then(([labelsArray, predsArray]) => {
            const counts = Array(numClasses).fill(0);
            const accuracy = Array(numClasses).fill(0);
            for (let i = 0; i < labelsArray.length; i++) {
                const label = labelsArray[i];
                const pred = predsArray[i];
                counts[label] += 1;
                if (label === pred) {
                    accuracy[label] += 1;
                }
            }
            const results = [];
            for (let i = 0; i < counts.length; i++) {
                results.push({
                    count: counts[i],
                    accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i],
                });
            }
            return results;
        });
    });
}
exports.perClassAccuracy = perClassAccuracy;
//# sourceMappingURL=math.js.map